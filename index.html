<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRTå­—å¹•æ‰¹é‡ç¿»è¯‘å·¥å…· - è‡ªåŠ¨ä¿å­˜ç‰ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 20px;
        }
        .container { max-width: 1200px; margin: 0 auto; }
        h1 {
            text-align: center;
            color: #00d4ff;
            margin-bottom: 20px;
            font-size: 2em;
        }
        .notice {
            background: rgba(255, 170, 0, 0.2);
            border: 1px solid #ffaa00;
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 20px;
            color: #ffaa00;
        }
        .panel {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 15px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .panel-title {
            color: #00d4ff;
            font-size: 1.2em;
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(0, 212, 255, 0.3);
        }
        .config-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
            flex-wrap: wrap;
        }
        .config-row label { min-width: 80px; color: #aaa; }
        .config-row input, .config-row select {
            flex: 1;
            min-width: 150px;
            padding: 8px 12px;
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 6px;
            background: rgba(0, 0, 0, 0.3);
            color: #fff;
        }
        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 8px;
            font-size: 15px;
            cursor: pointer;
            transition: all 0.3s;
            font-weight: bold;
        }
        .btn-primary { background: linear-gradient(135deg, #00d4ff, #0099cc); color: #fff; }
        .btn-success { background: linear-gradient(135deg, #00ff88, #00cc6a); color: #000; }
        .btn-danger { background: linear-gradient(135deg, #ff4444, #cc0000); color: #fff; }
        .btn-secondary { background: #555; color: #fff; }
        .btn:hover { transform: translateY(-2px); box-shadow: 0 5px 15px rgba(0,0,0,0.3); }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; transform: none; }
        .btn-group { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 15px; }
        .file-list {
            max-height: 350px;
            overflow-y: auto;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 10px;
            margin-top: 15px;
        }
        .file-item {
            display: flex;
            align-items: center;
            padding: 10px;
            margin-bottom: 5px;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 6px;
            gap: 10px;
        }
        .file-item .name { flex: 1; font-size: 13px; }
        .file-item .status { min-width: 100px; text-align: right; font-size: 12px; }
        .file-item.pending .status { color: #aaa; }
        .file-item.processing .status { color: #00d4ff; }
        .file-item.completed .status { color: #00ff88; }
        .file-item.failed .status { color: #ff4444; }
        .file-item.skipped .status { color: #ffaa00; }
        .progress-bar-container {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            height: 30px;
            overflow: hidden;
            margin: 15px 0;
        }
        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #000;
            font-weight: bold;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin: 15px 0;
        }
        .stat-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 8px;
            padding: 15px;
            text-align: center;
        }
        .stat-value { font-size: 2em; font-weight: bold; color: #00d4ff; }
        .stat-label { color: #888; font-size: 12px; }
        .log-area {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 12px;
            height: 150px;
            overflow-y: auto;
            font-family: 'Consolas', monospace;
            font-size: 12px;
        }
        .log-entry { margin-bottom: 4px; }
        .log-entry.success { color: #00ff88; }
        .log-entry.error { color: #ff4444; }
        .log-entry.info { color: #00d4ff; }
        .log-entry.warning { color: #ffaa00; }
        .checkbox-group { display: flex; align-items: center; gap: 8px; }
        .checkbox-group input { width: 18px; height: 18px; }
        #folderPath {
            background: rgba(0, 212, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 15px 0;
            word-break: break-all;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ¬ SRTå­—å¹•æ‰¹é‡ç¿»è¯‘å·¥å…·</h1>
        
        <div class="notice">
            âš ï¸ <strong>é‡è¦æç¤º</strong>ï¼š
            <br>â€¢ <strong>ç‚¹å‡»é€‰æ‹©æ–‡ä»¶å¤¹</strong>ï¼šéœ€è¦ Chrome/Edge 86+ï¼Œå¯è‡ªåŠ¨ä¿å­˜åˆ°åŸä½ç½®ï¼ˆä»… HTTPS æˆ–æœ¬æœºå¯ç”¨ï¼‰
            <br>â€¢ <strong>æ‹–æ‹½æ–‡ä»¶å¤¹</strong>ï¼šæ‰€æœ‰æµè§ˆå™¨éƒ½æ”¯æŒï¼Œç¿»è¯‘åè‡ªåŠ¨ä¸‹è½½ï¼ˆé€‚åˆå±€åŸŸç½‘è®¿é—®ï¼‰
            <br>â€¢ åªç¿»è¯‘æ–‡ä»¶åå«"æ—¥è¯­"æˆ–"éŸ©è¯­"çš„ SRT æ–‡ä»¶
        </div>
        
        <div class="panel">
            <div class="panel-title">âš™ï¸ APIé…ç½®</div>
            <div class="config-row">
                <label>APIåœ°å€:</label>
                <input type="text" id="apiUrl" value="">
            </div>
            <div class="config-row">
                <label>APIå¯†é’¥:</label>
                <input type="password" id="apiKey" value="sk-svbzdauociqyfapawnuarwmuetllcbbkqtpbvefuqpjcinbo">
            </div>
            <div class="config-row">
                <label>æ¨¡å‹:</label>
                <input type="text" id="model" value="deepseek-ai/DeepSeek-V3">
                <label>æ‰¹é‡:</label>
                <select id="batchSize">
                    <option value="10">10æ¡</option>
                    <option value="15">15æ¡</option>
                    <option value="20" selected>20æ¡</option>
                    <option value="30">30æ¡</option>
                </select>
            </div>
            <div class="config-row">
                <div class="checkbox-group">
                    <input type="checkbox" id="filterByName" checked>
                    <label for="filterByName">åªç¿»è¯‘æ–‡ä»¶åå«"æ—¥è¯­"æˆ–"éŸ©è¯­"çš„æ–‡ä»¶</label>
                </div>
            </div>
        </div>
        
        <div class="panel" id="dropZone">
            <div class="panel-title">ğŸ“ é€‰æ‹©æ–‡ä»¶å¤¹</div>
            <p style="color: #aaa; margin-bottom: 15px;">é€‰æ‹©åŒ…å«SRTå­—å¹•æ–‡ä»¶çš„æ–‡ä»¶å¤¹ï¼Œç¿»è¯‘åçš„æ–‡ä»¶å°†è‡ªåŠ¨ä¿å­˜åˆ°åŒä¸€ä½ç½®</p>
            
            <div style="border: 2px dashed rgba(0, 212, 255, 0.5); border-radius: 10px; padding: 30px; text-align: center; margin-bottom: 15px; cursor: pointer;" id="dropArea" onclick="selectFolder()">
                <p style="font-size: 18px; color: #00d4ff;">ğŸ“‚ ç‚¹å‡»é€‰æ‹©æ–‡ä»¶å¤¹ï¼ˆæ¨èï¼Œå¯è‡ªåŠ¨ä¿å­˜ï¼‰</p>
                <p style="color: #888; margin-top: 10px;">æˆ–æ‹–æ‹½æ–‡ä»¶å¤¹åˆ°æ­¤å¤„ï¼ˆç¿»è¯‘åä¸‹è½½ï¼‰</p>
            </div>
            
            <div id="folderPath" style="display: none;">
                <strong>å·²é€‰æ‹©:</strong> <span id="folderName"></span>
            </div>
            
            <div class="file-list" id="fileList" style="display: none;"></div>
            
            <div class="btn-group">
                <span style="color: #aaa;" id="fileCount">å…± 0 ä¸ªæ–‡ä»¶</span>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-title">ğŸ“Š ç¿»è¯‘è¿›åº¦</div>
            <div id="statusText" style="color: #aaa;">ç­‰å¾…é€‰æ‹©æ–‡ä»¶å¤¹...</div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progressBar">0%</div>
            </div>
            <div class="stats">
                <div class="stat-card">
                    <div class="stat-value" id="totalCount">0</div>
                    <div class="stat-label">æ€»æ–‡ä»¶</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="completedCount">0</div>
                    <div class="stat-label">å·²å®Œæˆ</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="skippedCount">0</div>
                    <div class="stat-label">å·²è·³è¿‡</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="errorCount">0</div>
                    <div class="stat-label">å¤±è´¥</div>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn btn-success" id="startBtn" onclick="startTranslation()" disabled>ğŸš€ å¼€å§‹ç¿»è¯‘</button>
                <button class="btn btn-danger" id="stopBtn" onclick="stopTranslation()" style="display:none;">â¹ï¸ åœæ­¢</button>
            </div>
        </div>
        
        <div class="panel">
            <div class="panel-title">ğŸ“ æ—¥å¿—</div>
            <div class="log-area" id="logArea"></div>
        </div>
    </div>

    <script>
        let rootHandle = null;
        let files = []; // {handle, path, name, status}
        let shouldStop = false;
        
        // è‡ªåŠ¨æ£€æµ‹å¹¶è®¾ç½® API åœ°å€
        // ä½¿ç”¨ SiliconFlowï¼ˆç¡…åŸºæµåŠ¨ï¼‰çš„ HTTPS APIï¼Œå›½å†…å¯ç›´æ¥è®¿é—®
        function initApiUrl() {
            // é»˜è®¤ä½¿ç”¨ SiliconFlow HTTPS APIï¼ˆå›½å†…å¯ç”¨ï¼‰
            document.getElementById('apiUrl').value = 'https://api.siliconflow.cn/v1/chat/completions';
        }
        
        // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
        if (!('showDirectoryPicker' in window)) {
            document.querySelector('.notice').innerHTML = 
                'âŒ <strong>æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒFile System Access API</strong><br>' +
                'è¯·ä½¿ç”¨ Chrome 86+ æˆ– Edge 86+ æµè§ˆå™¨ï¼Œæˆ–è€…ä½¿ç”¨æ¡Œé¢ç‰ˆå·¥å…·ã€‚';
            document.querySelector('.notice').style.borderColor = '#ff4444';
            document.querySelector('.notice').style.background = 'rgba(255, 68, 68, 0.2)';
        }
        
        // æ‰«æç»Ÿè®¡
        let scanStats = { total: 0, chinese: 0, added: 0 };
        
        // é€‰æ‹©æ–‡ä»¶å¤¹
        async function selectFolder() {
            try {
                rootHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                document.getElementById('folderName').textContent = rootHandle.name;
                document.getElementById('folderPath').style.display = 'block';
                
                addLog(`å·²é€‰æ‹©æ–‡ä»¶å¤¹: ${rootHandle.name}`, 'success');
                
                // æ‰«æSRTæ–‡ä»¶
                files = [];
                scanStats = { total: 0, skipped: 0, added: 0 };
                const filterByName = document.getElementById('filterByName').checked;
                
                document.getElementById('statusText').textContent = 'æ­£åœ¨æ‰«ææ–‡ä»¶...';
                await scanDirectory(rootHandle, '', filterByName);
                
                updateFileList();
                document.getElementById('startBtn').disabled = files.length === 0;
                
                if (filterByName && scanStats.skipped > 0) {
                    addLog(`æ‰«æå®Œæˆ: å…± ${scanStats.total} ä¸ªSRTæ–‡ä»¶ï¼Œ${scanStats.skipped} ä¸ªå·²è·³è¿‡ï¼ˆæ–‡ä»¶åä¸å«æ—¥è¯­/éŸ©è¯­ï¼‰ï¼Œ${scanStats.added} ä¸ªå¾…ç¿»è¯‘`, 'info');
                } else {
                    addLog(`æ‰¾åˆ° ${files.length} ä¸ªSRTæ–‡ä»¶`, 'info');
                }
                document.getElementById('statusText').textContent = files.length > 0 ? 'å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»å¼€å§‹ç¿»è¯‘' : 'æœªæ‰¾åˆ°éœ€è¦ç¿»è¯‘çš„æ–‡ä»¶';
            } catch (err) {
                if (err.name !== 'AbortError') {
                    addLog(`é€‰æ‹©æ–‡ä»¶å¤¹å¤±è´¥: ${err.message}`, 'error');
                }
                document.getElementById('statusText').textContent = 'ç­‰å¾…é€‰æ‹©æ–‡ä»¶å¤¹...';
            }
        }
        
        // æ£€æµ‹æ–‡ä»¶åæ˜¯å¦åŒ…å«"æ—¥è¯­"æˆ–"éŸ©è¯­"
        function shouldTranslate(fileName) {
            return fileName.includes('æ—¥è¯­') || fileName.includes('éŸ©è¯­');
        }
        
        // é€’å½’æ‰«æç›®å½•
        async function scanDirectory(dirHandle, path, filterByName) {
            let count = 0;
            for await (const entry of dirHandle.values()) {
                if (entry.kind === 'file' && entry.name.toLowerCase().endsWith('.srt')) {
                    // è·³è¿‡å·²ç¿»è¯‘çš„æ–‡ä»¶ï¼ˆå¸¦ _ä¸­æ–‡ åç¼€çš„ï¼‰
                    const isTranslatedFile = entry.name.includes('_ä¸­æ–‡');
                    if (!isTranslatedFile) {
                        scanStats.total++;
                        document.getElementById('statusText').textContent = `æ­£åœ¨æ‰«æ... å·²æ£€æµ‹ ${scanStats.total} ä¸ªæ–‡ä»¶`;
                        
                        // åªç¿»è¯‘æ–‡ä»¶åå«"æ—¥è¯­"æˆ–"éŸ©è¯­"çš„æ–‡ä»¶
                        if (filterByName && !shouldTranslate(entry.name)) {
                            scanStats.skipped++;
                            addLog(`è·³è¿‡: ${path}${entry.name}ï¼ˆæ–‡ä»¶åä¸å«æ—¥è¯­/éŸ©è¯­ï¼‰`, 'warning');
                            continue;
                        }
                        
                        files.push({
                            handle: entry,
                            dirHandle: dirHandle,
                            path: path,
                            name: entry.name,
                            status: 'pending'
                        });
                        scanStats.added++;
                        count++;
                        addLog(`æ·»åŠ æ–‡ä»¶: ${path}${entry.name}`, 'success');
                    }
                } else if (entry.kind === 'directory') {
                    await scanDirectory(entry, path + entry.name + '/', filterByName);
                }
            }
        }
        
        // æ›´æ–°æ–‡ä»¶åˆ—è¡¨
        function updateFileList() {
            const list = document.getElementById('fileList');
            if (files.length === 0) {
                list.style.display = 'none';
                return;
            }
            
            list.style.display = 'block';
            list.innerHTML = files.map((f, i) => `
                <div class="file-item ${f.status}" id="file-${i}">
                    <span class="name">${f.path}${f.name}</span>
                    <span class="status">${getStatusText(f.status)}</span>
                </div>
            `).join('');
            
            document.getElementById('fileCount').textContent = `å…± ${files.length} ä¸ªæ–‡ä»¶`;
            updateStats();
        }
        
        function getStatusText(s) {
            return { pending: 'å¾…å¤„ç†', processing: 'ç¿»è¯‘ä¸­...', completed: 'âœ“ å·²ä¿å­˜', failed: 'âœ— å¤±è´¥', skipped: 'âŠ˜ è·³è¿‡' }[s] || s;
        }
        
        function updateStats() {
            const total = files.length;
            const completed = files.filter(f => f.status === 'completed').length;
            const skipped = files.filter(f => f.status === 'skipped').length;
            const failed = files.filter(f => f.status === 'failed').length;
            
            document.getElementById('totalCount').textContent = total;
            document.getElementById('completedCount').textContent = completed;
            document.getElementById('skippedCount').textContent = skipped;
            document.getElementById('errorCount').textContent = failed;
            
            const done = completed + skipped + failed;
            const pct = total > 0 ? Math.round((done / total) * 100) : 0;
            document.getElementById('progressBar').style.width = pct + '%';
            document.getElementById('progressBar').textContent = pct + '%';
        }
        
        // æ£€æµ‹æ–‡æœ¬ç¼–ç å¹¶è§£ç 
        async function readFileWithEncoding(file) {
            const buffer = await file.arrayBuffer();
            const bytes = new Uint8Array(buffer);
            
            // æ£€æµ‹BOMæ ‡è®°
            if (bytes[0] === 0xEF && bytes[1] === 0xBB && bytes[2] === 0xBF) {
                return new TextDecoder('utf-8').decode(buffer);
            }
            if (bytes[0] === 0xFF && bytes[1] === 0xFE) {
                return new TextDecoder('utf-16le').decode(buffer);
            }
            if (bytes[0] === 0xFE && bytes[1] === 0xFF) {
                return new TextDecoder('utf-16be').decode(buffer);
            }
            
            // å°è¯•æ£€æµ‹æ˜¯å¦ä¸ºæœ‰æ•ˆçš„UTF-8
            if (isValidUTF8(bytes)) {
                const text = new TextDecoder('utf-8').decode(buffer);
                if (!text.includes('\uFFFD\uFFFD')) {
                    return text;
                }
            }
            
            // å°è¯•GBKç¼–ç 
            try {
                const gbkText = new TextDecoder('gbk').decode(buffer);
                if (/[\u4e00-\u9fff]/.test(gbkText) && !gbkText.includes('\uFFFD')) {
                    return gbkText;
                }
            } catch (e) {}
            
            // å°è¯•Shift_JISç¼–ç ï¼ˆæ—¥è¯­ï¼‰
            try {
                const sjisText = new TextDecoder('shift_jis').decode(buffer);
                if (/[\u3040-\u309f\u30a0-\u30ff]/.test(sjisText) && !sjisText.includes('\uFFFD')) {
                    return sjisText;
                }
            } catch (e) {}
            
            // å°è¯•EUC-KRç¼–ç ï¼ˆéŸ©è¯­ï¼‰
            try {
                const euckrText = new TextDecoder('euc-kr').decode(buffer);
                if (/[\uac00-\ud7af]/.test(euckrText) && !euckrText.includes('\uFFFD')) {
                    return euckrText;
                }
            } catch (e) {}
            
            return new TextDecoder('utf-8').decode(buffer);
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„UTF-8ç¼–ç 
        function isValidUTF8(bytes) {
            let i = 0;
            while (i < bytes.length) {
                if (bytes[i] < 0x80) {
                    i++;
                } else if ((bytes[i] & 0xE0) === 0xC0) {
                    if (i + 1 >= bytes.length || (bytes[i + 1] & 0xC0) !== 0x80) return false;
                    i += 2;
                } else if ((bytes[i] & 0xF0) === 0xE0) {
                    if (i + 2 >= bytes.length || (bytes[i + 1] & 0xC0) !== 0x80 || (bytes[i + 2] & 0xC0) !== 0x80) return false;
                    i += 3;
                } else if ((bytes[i] & 0xF8) === 0xF0) {
                    if (i + 3 >= bytes.length || (bytes[i + 1] & 0xC0) !== 0x80 || (bytes[i + 2] & 0xC0) !== 0x80 || (bytes[i + 3] & 0xC0) !== 0x80) return false;
                    i += 4;
                } else {
                    return false;
                }
            }
            return true;
        }
        
        // å¼€å§‹ç¿»è¯‘
        async function startTranslation() {
            if (files.length === 0) return;
            
            shouldStop = false;
            document.getElementById('startBtn').style.display = 'none';
            document.getElementById('stopBtn').style.display = 'inline-block';
            
            // æ”¶é›†æ‰€æœ‰éœ€è¦æƒé™çš„æ–‡ä»¶å¤¹ï¼Œä¸€æ¬¡æ€§è¯·æ±‚
            const dirHandles = new Set();
            for (const f of files) {
                if (f.dirHandle) {
                    dirHandles.add(f.dirHandle);
                }
            }
            
            // ä¸€æ¬¡æ€§è¯·æ±‚æ‰€æœ‰æ–‡ä»¶å¤¹çš„å†™å…¥æƒé™
            if (dirHandles.size > 0) {
                addLog(`è¯·æ±‚ ${dirHandles.size} ä¸ªæ–‡ä»¶å¤¹çš„å†™å…¥æƒé™...`, 'info');
                for (const dirHandle of dirHandles) {
                    try {
                        await dirHandle.requestPermission({ mode: 'readwrite' });
                    } catch (e) {
                        addLog(`æƒé™è¯·æ±‚å¤±è´¥: ${dirHandle.name}`, 'warning');
                    }
                }
            }
            
            addLog('å¼€å§‹æ‰¹é‡ç¿»è¯‘...', 'info');
            
            for (let i = 0; i < files.length; i++) {
                if (shouldStop) {
                    addLog('ç¿»è¯‘å·²åœæ­¢', 'warning');
                    break;
                }
                
                const f = files[i];
                if (f.status !== 'pending') continue;
                
                document.getElementById('statusText').textContent = `å¤„ç† ${i+1}/${files.length}: ${f.name}`;
                
                f.status = 'processing';
                updateFileItem(i);
                addLog(`ç¿»è¯‘: ${f.name}`, 'info');
                
                try {
                    // è¯»å–æ–‡ä»¶ï¼ˆè‡ªåŠ¨æ£€æµ‹ç¼–ç ï¼‰
                    let content;
                    if (f.handle) {
                        const file = await f.handle.getFile();
                        content = await readFileWithEncoding(file);
                    } else if (f.file) {
                        content = await readFileWithEncoding(f.file);
                    }
                    
                    // ç¿»è¯‘
                    const result = await translateSRT(content);
                    
                    // ä¿å­˜åˆ°åŸä½ç½®ï¼ˆå¦‚æœæœ‰dirHandleï¼‰
                    const newName = f.name.replace(/\.srt$/i, '_ä¸­æ–‡.srt');
                    let saved = false;
                    
                    if (f.dirHandle) {
                        try {
                            const newHandle = await f.dirHandle.getFileHandle(newName, { create: true });
                            const writable = await newHandle.createWritable();
                            await writable.write(result);
                            await writable.close();
                            saved = true;
                            f.status = 'completed';
                            addLog(`âœ“ å·²ä¿å­˜: ${f.path}${newName}`, 'success');
                        } catch (saveErr) {
                            addLog(`ä¿å­˜å¤±è´¥: ${saveErr.message}`, 'warning');
                        }
                    }
                    
                    // å¦‚æœä¿å­˜å¤±è´¥æˆ–æ²¡æœ‰dirHandleï¼Œè§¦å‘ä¸‹è½½
                    if (!saved) {
                        const blob = new Blob([result], { type: 'text/plain;charset=utf-8' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = newName;
                        a.click();
                        URL.revokeObjectURL(url);
                        f.status = 'completed';
                        addLog(`âœ“ å·²ä¸‹è½½: ${newName}`, 'success');
                    }
                } catch (err) {
                    f.status = 'failed';
                    addLog(`âœ— å¤±è´¥: ${f.name} - ${err.message}`, 'error');
                }
                
                updateFileItem(i);
                
                if (i < files.length - 1 && !shouldStop) {
                    await new Promise(r => setTimeout(r, 500));
                }
            }
            
            document.getElementById('startBtn').style.display = 'inline-block';
            document.getElementById('stopBtn').style.display = 'none';
            
            const done = files.filter(f => f.status === 'completed').length;
            document.getElementById('statusText').textContent = `å®Œæˆï¼æˆåŠŸç¿»è¯‘ ${done} ä¸ªæ–‡ä»¶`;
            addLog(`æ‰¹é‡ç¿»è¯‘å®Œæˆï¼ŒæˆåŠŸ: ${done}`, 'success');
        }
        
        function updateFileItem(i) {
            const el = document.getElementById(`file-${i}`);
            if (el) {
                el.className = `file-item ${files[i].status}`;
                el.querySelector('.status').textContent = getStatusText(files[i].status);
            }
            updateStats();
        }
        
        // ç¿»è¯‘SRT
        async function translateSRT(content) {
            const subs = parseSRT(content);
            if (subs.length === 0) throw new Error('æ— æ³•è§£æ');
            
            const apiUrl = document.getElementById('apiUrl').value;
            const apiKey = document.getElementById('apiKey').value;
            const model = document.getElementById('model').value;
            const batchSize = parseInt(document.getElementById('batchSize').value);
            
            const result = [];
            
            for (let i = 0; i < subs.length; i += batchSize) {
                if (shouldStop) throw new Error('å·²åœæ­¢');
                
                const batch = subs.slice(i, i + batchSize);
                const texts = batch.map((s, j) => `[${j+1}] ${s.text}`).join('\n');
                
                const resp = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${apiKey}` },
                    body: JSON.stringify({
                        model,
                        messages: [{ 
                            role: 'user', 
                            content: `ä½ æ˜¯ä¸“ä¸šå­—å¹•ç¿»è¯‘å‘˜ã€‚å°†ä»¥ä¸‹å­—å¹•ç¿»è¯‘æˆç®€ä½“ä¸­æ–‡ã€‚

è§„åˆ™ï¼š
1. ä¿æŒ[æ•°å­—]æ ¼å¼ä¸å˜
2. æ¯è¡Œç¿»è¯‘å¯¹åº”åŸæ–‡çš„[æ•°å­—]
3. åªè¾“å‡ºç¿»è¯‘ç»“æœï¼Œä¸è¦è§£é‡Š

åŸæ–‡ï¼š
${texts}` 
                        }],
                        temperature: 0.3,
                        max_tokens: 4000
                    })
                });
                
                if (!resp.ok) throw new Error(`API ${resp.status}`);
                
                const data = await resp.json();
                const lines = data.choices[0].message.content.split('\n');
                
                for (let line of lines) {
                    const m = line.match(/\[(\d+)\]\s*(.+)/);
                    if (m) {
                        const idx = parseInt(m[1]) - 1;
                        if (idx >= 0 && idx < batch.length) {
                            result.push({ ...batch[idx], text: m[2].trim() });
                        }
                    }
                }
                
                // å¡«å……
                while (result.length < i + batch.length) {
                    const idx = result.length - i;
                    if (idx < batch.length) result.push({ ...batch[idx] });
                    else break;
                }
            }
            
            return result.map(s => `${s.index}\n${s.start} --> ${s.end}\n${s.text}`).join('\n\n');
        }
        
        function parseSRT(content) {
            const result = [];
            const blocks = content.trim().split(/\n\s*\n/);
            for (const b of blocks) {
                const lines = b.trim().split('\n');
                if (lines.length >= 3) {
                    const idx = parseInt(lines[0]);
                    const tm = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
                    if (tm && !isNaN(idx)) {
                        result.push({ index: idx, start: tm[1], end: tm[2], text: lines.slice(2).join('\n') });
                    }
                }
            }
            return result;
        }
        
        function stopTranslation() {
            shouldStop = true;
            addLog('æ­£åœ¨åœæ­¢...', 'warning');
        }
        
        function addLog(msg, type = 'info') {
            const t = new Date().toLocaleTimeString();
            const el = document.createElement('div');
            el.className = `log-entry ${type}`;
            el.textContent = `[${t}] ${msg}`;
            document.getElementById('logArea').appendChild(el);
            document.getElementById('logArea').scrollTop = 99999;
        }
        
        // åˆå§‹åŒ– API åœ°å€
        initApiUrl();
        addLog('å·¥å…·å·²å°±ç»ªï¼Œè¯·é€‰æ‹©æ–‡ä»¶å¤¹æˆ–æ‹–æ‹½SRTæ–‡ä»¶', 'info');
        
        // æ‹–æ‹½åŠŸèƒ½
        const dropArea = document.getElementById('dropArea');
        
        dropArea.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropArea.style.borderColor = '#00ff88';
            dropArea.style.background = 'rgba(0, 255, 136, 0.1)';
        });
        
        dropArea.addEventListener('dragleave', (e) => {
            e.preventDefault();
            dropArea.style.borderColor = 'rgba(0, 212, 255, 0.5)';
            dropArea.style.background = 'transparent';
        });
        
        dropArea.addEventListener('drop', async (e) => {
            e.preventDefault();
            e.stopPropagation();
            dropArea.style.borderColor = 'rgba(0, 212, 255, 0.5)';
            dropArea.style.background = 'transparent';
            
            addLog('æ£€æµ‹åˆ°æ‹–æ‹½äº‹ä»¶...', 'info');
            
            files = [];
            rootHandle = null;
            scanStats = { total: 0, skipped: 0, added: 0 };
            const items = e.dataTransfer.items;
            const filterByName = document.getElementById('filterByName').checked;
            
            addLog(`æ‹–å…¥äº† ${items.length} ä¸ªé¡¹ç›®`, 'info');
            document.getElementById('statusText').textContent = 'æ­£åœ¨æ£€æµ‹æ–‡ä»¶...';
            
            // å…ˆåŒæ­¥æ”¶é›†æ‰€æœ‰ handlesï¼ˆå› ä¸º DataTransferItemList åœ¨å¼‚æ­¥åä¼šå¤±æ•ˆï¼‰
            const handlePromises = [];
            const fallbackFiles = [];
            
            for (let i = 0; i < items.length; i++) {
                const item = items[i];
                if (item.kind === 'file') {
                    if (item.getAsFileSystemHandle) {
                        // åŒæ­¥å¯åŠ¨æ‰€æœ‰ Promise
                        handlePromises.push(item.getAsFileSystemHandle());
                    } else {
                        // é™çº§ï¼šåŒæ­¥è·å–æ–‡ä»¶
                        const file = item.getAsFile();
                        if (file) fallbackFiles.push(file);
                    }
                }
            }
            
            // ç­‰å¾…æ‰€æœ‰ handles
            const handles = await Promise.all(handlePromises);
            addLog(`è·å–åˆ° ${handles.length} ä¸ªæ–‡ä»¶ç³»ç»Ÿå¥æŸ„`, 'info');
            
            // æ”¶é›†æ‰€æœ‰æ–‡ä»¶å¤¹åç§°
            let folderNames = [];
            
            // å¤„ç† handles
            for (const handle of handles) {
                if (handle && handle.kind === 'directory') {
                    if (!rootHandle) {
                        rootHandle = handle;
                    }
                    folderNames.push(handle.name);
                    addLog(`æ‰«ææ–‡ä»¶å¤¹: ${handle.name}`, 'success');
                    await scanDirectory(handle, handle.name + '/', filterByName);
                } else if (handle && handle.kind === 'file' && handle.name.toLowerCase().endsWith('.srt')) {
                    const isTranslatedFile = handle.name.includes('_ä¸­æ–‡');
                    if (!isTranslatedFile) {
                        scanStats.total++;
                        document.getElementById('statusText').textContent = `æ­£åœ¨æ£€æµ‹... å·²æ£€æµ‹ ${scanStats.total} ä¸ªæ–‡ä»¶`;
                        
                        if (filterByName && !shouldTranslate(handle.name)) {
                            scanStats.skipped++;
                            addLog(`è·³è¿‡: ${handle.name}ï¼ˆæ–‡ä»¶åä¸å«æ—¥è¯­/éŸ©è¯­ï¼‰`, 'warning');
                            continue;
                        }
                        
                        files.push({
                            handle: handle,
                            dirHandle: null,
                            path: '',
                            name: handle.name,
                            status: 'pending'
                        });
                        scanStats.added++;
                        addLog(`æ·»åŠ æ–‡ä»¶: ${handle.name}`, 'success');
                    }
                }
            }
            
            // å¤„ç†é™çº§æ–‡ä»¶
            for (const file of fallbackFiles) {
                const isTranslatedFile = file.name.includes('_ä¸­æ–‡');
                if (file.name.toLowerCase().endsWith('.srt') && !isTranslatedFile) {
                    scanStats.total++;
                    document.getElementById('statusText').textContent = `æ­£åœ¨æ£€æµ‹... å·²æ£€æµ‹ ${scanStats.total} ä¸ªæ–‡ä»¶`;
                    
                    if (filterByName && !shouldTranslate(file.name)) {
                        scanStats.skipped++;
                        addLog(`è·³è¿‡: ${file.name}ï¼ˆæ–‡ä»¶åä¸å«æ—¥è¯­/éŸ©è¯­ï¼‰`, 'warning');
                        continue;
                    }
                    
                    files.push({
                        handle: null,
                        file: file,
                        dirHandle: null,
                        path: '',
                        name: file.name,
                        status: 'pending'
                    });
                    scanStats.added++;
                    addLog(`æ·»åŠ æ–‡ä»¶(åªè¯»): ${file.name}`, 'warning');
                }
            }
            
            // æ›´æ–°æ–‡ä»¶å¤¹æ˜¾ç¤º
            if (folderNames.length > 0) {
                document.getElementById('folderName').textContent = folderNames.length === 1
                    ? folderNames[0]
                    : `${folderNames.length} ä¸ªæ–‡ä»¶å¤¹: ${folderNames.join(', ')}`;
                document.getElementById('folderPath').style.display = 'block';
            }
            
            updateFileList();
            document.getElementById('startBtn').disabled = files.length === 0;
            
            if (filterByName && scanStats.skipped > 0) {
                addLog(`æ£€æµ‹å®Œæˆ: å…± ${scanStats.total} ä¸ªSRTæ–‡ä»¶ï¼Œ${scanStats.skipped} ä¸ªå·²è·³è¿‡ï¼ˆæ–‡ä»¶åä¸å«æ—¥è¯­/éŸ©è¯­ï¼‰ï¼Œ${scanStats.added} ä¸ªå¾…ç¿»è¯‘`, 'info');
            } else {
                addLog(`å…±æ‰¾åˆ° ${files.length} ä¸ªSRTæ–‡ä»¶`, 'info');
            }
            document.getElementById('statusText').textContent = files.length > 0 ? 'å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»å¼€å§‹ç¿»è¯‘' : 'æœªæ‰¾åˆ°éœ€è¦ç¿»è¯‘çš„æ–‡ä»¶';
        });
    </script>
</body>
</html>
