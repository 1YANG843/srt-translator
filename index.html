<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SRTå­—å¹•æ‰¹é‡ç¿»è¯‘ - 20çª—å£å¹¶è¡Œç‰ˆ</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            min-height: 100vh;
            color: #e0e0e0;
            padding: 15px;
        }
        .container { max-width: 1900px; margin: 0 auto; }
        
        /* æ ‡é¢˜åŒºåŸŸ */
        header {
            text-align: center;
            padding: 15px 0;
            border-bottom: 2px solid #00d4ff;
            margin-bottom: 15px;
        }
        h1 { font-size: 1.6em; color: #00d4ff; }
        .version-badge {
            display: inline-block;
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: white;
            padding: 3px 12px;
            border-radius: 12px;
            font-size: 0.6em;
            margin-left: 10px;
        }
        .subtitle { color: #888; font-size: 0.85em; margin-top: 5px; }
        
        /* å…¨å±€é…ç½®åŒºåŸŸ */
        .global-config {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            margin-bottom: 15px;
            border: 1px solid rgba(0, 212, 255, 0.3);
        }
        .config-title { color: #00d4ff; font-size: 1em; margin-bottom: 10px; }
        .config-row {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            align-items: center;
        }
        .config-item { flex: 1; min-width: 180px; }
        .config-item label { display: block; color: #888; margin-bottom: 4px; font-size: 0.8em; }
        .config-item input, .config-item select {
            width: 100%;
            padding: 8px 10px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(0, 212, 255, 0.3);
            border-radius: 6px;
            color: #e0e0e0;
            font-size: 13px;
        }
        .config-item input:focus, .config-item select:focus {
            outline: none;
            border-color: #00d4ff;
        }
        
        /* æ–‡ä»¶æ‹–æ”¾åŒºåŸŸ */
        .drop-zone {
            background: rgba(0, 0, 0, 0.3);
            border: 2px dashed rgba(0, 212, 255, 0.5);
            border-radius: 10px;
            padding: 30px;
            text-align: center;
            margin-bottom: 15px;
            cursor: pointer;
            transition: all 0.3s;
        }
        .drop-zone:hover, .drop-zone.dragover {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.1);
        }
        .drop-zone-icon { font-size: 2.5em; margin-bottom: 10px; }
        .drop-zone-text { color: #00d4ff; font-size: 1.1em; }
        .drop-zone-hint { color: #888; font-size: 0.85em; margin-top: 8px; }
        
        /* é˜Ÿåˆ—çŠ¶æ€æ  */
        .status-bar {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px 15px;
            margin-bottom: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 10px;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }
        .stats-group {
            display: flex;
            gap: 20px;
            flex-wrap: wrap;
        }
        .stat-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        .stat-label { color: #888; font-size: 0.85em; }
        .stat-value { 
            font-weight: bold; 
            font-size: 1.1em;
            min-width: 30px;
            text-align: center;
        }
        .stat-value.pending { color: #ffaa00; }
        .stat-value.processing { color: #00d4ff; }
        .stat-value.completed { color: #00ff88; }
        .stat-value.failed { color: #ff4444; }
        
        .btn-group { display: flex; gap: 10px; }
        button {
            padding: 10px 20px;
            font-size: 0.9em;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }
        .btn-primary {
            background: linear-gradient(135deg, #00d4ff, #0099cc);
            color: white;
        }
        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 212, 255, 0.4);
        }
        .btn-warning {
            background: linear-gradient(135deg, #ffaa00, #cc8800);
            color: white;
        }
        .btn-danger {
            background: linear-gradient(135deg, #ff4444, #cc0000);
            color: white;
        }
        .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #e0e0e0;
            border: 1px solid rgba(255, 255, 255, 0.3);
        }
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }
        
        /* çª—å£ç½‘æ ¼ */
        .windows-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
            margin-bottom: 15px;
        }
        @media (max-width: 1400px) { .windows-grid { grid-template-columns: repeat(3, 1fr); } }
        @media (max-width: 900px) { .windows-grid { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { .windows-grid { grid-template-columns: 1fr; } }
        
        /* çª—å£å¡ç‰‡ */
        .window-card {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 12px;
            border: 2px solid rgba(100, 100, 100, 0.3);
            transition: all 0.3s;
            min-height: 200px;
            display: flex;
            flex-direction: column;
        }
        .window-card.idle { border-color: rgba(100, 100, 100, 0.3); }
        .window-card.processing { 
            border-color: #00d4ff; 
            background: rgba(0, 212, 255, 0.1);
            box-shadow: 0 0 15px rgba(0, 212, 255, 0.2);
        }
        .window-card.completed { 
            border-color: #00ff88; 
            background: rgba(0, 255, 136, 0.1);
        }
        .window-card.error { 
            border-color: #ff4444; 
            background: rgba(255, 68, 68, 0.1);
        }
        
        .window-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(0, 212, 255, 0.2);
        }
        .window-title {
            font-weight: bold;
            color: #00d4ff;
            font-size: 0.95em;
        }
        .window-status {
            display: flex;
            align-items: center;
            gap: 5px;
            font-size: 0.75em;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(100, 100, 100, 0.5);
        }
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
        }
        .window-card.idle .status-dot { background: #666; }
        .window-card.processing .status-dot { 
            background: #00d4ff; 
            animation: pulse 1.5s infinite;
        }
        .window-card.completed .status-dot { background: #00ff88; }
        .window-card.error .status-dot { background: #ff4444; }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }
        
        .window-file {
            font-size: 0.85em;
            color: #aaa;
            margin-bottom: 8px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .window-file .icon { margin-right: 5px; }
        
        .window-progress {
            margin-bottom: 10px;
        }
        .progress-bar-bg {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            height: 20px;
            overflow: hidden;
            margin-bottom: 4px;
        }
        .progress-bar-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ff88);
            width: 0%;
            transition: width 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75em;
            font-weight: bold;
            color: #000;
        }
        .progress-text {
            font-size: 0.75em;
            color: #888;
            text-align: right;
        }
        
        .window-preview {
            flex: 1;
            background: rgba(0, 0, 0, 0.3);
            border-radius: 6px;
            padding: 8px;
            font-size: 0.8em;
            overflow: hidden;
        }
        .preview-label {
            color: #666;
            font-size: 0.85em;
            margin-bottom: 3px;
        }
        .preview-text {
            color: #aaa;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            margin-bottom: 6px;
        }
        .preview-text.translated { color: #00ff88; }
        
        .window-queue {
            margin-top: 8px;
            font-size: 0.8em;
            color: #888;
            text-align: center;
            padding: 5px;
            background: rgba(0, 0, 0, 0.2);
            border-radius: 4px;
        }
        .window-queue .count { color: #ffaa00; font-weight: bold; }
        
        /* æ—¥å¿—åŒºåŸŸ */
        .log-panel {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 10px;
            padding: 15px;
            border: 1px solid rgba(0, 212, 255, 0.2);
        }
        .log-title { color: #00d4ff; font-size: 1em; margin-bottom: 10px; }
        .log-area {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 6px;
            padding: 10px;
            height: 120px;
            overflow-y: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.8em;
        }
        .log-entry { margin-bottom: 4px; line-height: 1.4; }
        .log-entry.info { color: #00d4ff; }
        .log-entry.success { color: #00ff88; }
        .log-entry.warning { color: #ffaa00; }
        .log-entry.error { color: #ff4444; }
        
        /* åŠ è½½åŠ¨ç”» */
        .loading-spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top-color: #fff;
            animation: spin 1s linear infinite;
            margin-right: 5px;
            vertical-align: middle;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
    </style>
</head>
<body>
    <div class="container">
        <!-- æ ‡é¢˜åŒºåŸŸ -->
        <header>
            <h1>ğŸ¬ SRTå­—å¹•æ‰¹é‡ç¿»è¯‘ <span class="version-badge">20çª—å£å¹¶è¡Œç‰ˆ</span></h1>
            <p class="subtitle">20ä¸ªç‹¬ç«‹ç¿»è¯‘çª—å£ | æ‰¹é‡æ–‡ä»¶è‡ªåŠ¨åˆ†å‘ | å¹¶è¡Œå¤„ç†æå‡æ•ˆç‡</p>
        </header>
        
        <!-- å…¨å±€é…ç½®åŒºåŸŸ -->
        <div class="global-config">
            <div class="config-title">âš™ï¸ å…¨å±€é…ç½®</div>
            <div class="config-row">
                <div class="config-item" style="flex: 2;">
                    <label>APIåœ°å€</label>
                    <input type="text" id="apiUrl" value="https://api.siliconflow.cn/v1/chat/completions">
                </div>
                <div class="config-item" style="flex: 2;">
                    <label>APIå¯†é’¥</label>
                    <input type="password" id="apiKey" value="sk-svbzdauociqyfapawnuarwmuetllcbbkqtpbvefuqpjcinbo">
                </div>
                <div class="config-item">
                    <label>æ¨¡å‹</label>
                    <input type="text" id="model" value="deepseek-ai/DeepSeek-V3">
                </div>
                <div class="config-item" style="flex: 0.5;">
                    <label>æ‰¹é‡æ¡æ•°</label>
                    <select id="batchSize">
                        <option value="10">10æ¡</option>
                        <option value="15">15æ¡</option>
                        <option value="20" selected>20æ¡</option>
                        <option value="30">30æ¡</option>
                    </select>
                </div>
            </div>
        </div>
        
        <!-- æ–‡ä»¶æ‹–æ”¾åŒºåŸŸ -->
        <div class="drop-zone" id="dropZone">
            <div class="drop-zone-icon">ğŸ“‚</div>
            <div class="drop-zone-text">æ‹–æ‹½SRTæ–‡ä»¶åˆ°æ­¤å¤„ æˆ– ç‚¹å‡»é€‰æ‹©æ–‡ä»¶</div>
            <div class="drop-zone-hint">æ”¯æŒæ‰¹é‡æ‹–å…¥å¤šä¸ªæ–‡ä»¶ï¼Œè‡ªåŠ¨åˆ†é…åˆ°ç©ºé—²çª—å£å¤„ç†</div>
        </div>
        
        <!-- é˜Ÿåˆ—çŠ¶æ€æ  -->
        <div class="status-bar">
            <div class="stats-group">
                <div class="stat-item">
                    <span class="stat-label">å¾…å¤„ç†:</span>
                    <span class="stat-value pending" id="statPending">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">å¤„ç†ä¸­:</span>
                    <span class="stat-value processing" id="statProcessing">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">å·²å®Œæˆ:</span>
                    <span class="stat-value completed" id="statCompleted">0</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">å¤±è´¥:</span>
                    <span class="stat-value failed" id="statFailed">0</span>
                </div>
            </div>
            <div class="btn-group">
                <button class="btn-primary" id="btnStart" disabled>ğŸš€ å¼€å§‹ç¿»è¯‘</button>
                <button class="btn-warning" id="btnPause" disabled>â¸ï¸ æš‚åœ</button>
                <button class="btn-danger" id="btnClear">ğŸ—‘ï¸ æ¸…ç©ºé˜Ÿåˆ—</button>
            </div>
        </div>
        
        <!-- 15ä¸ªçª—å£ç½‘æ ¼ -->
        <div class="windows-grid" id="windowsGrid">
            <!-- çª—å£å°†ç”±JavaScriptåŠ¨æ€ç”Ÿæˆ -->
        </div>
        
        <!-- æ—¥å¿—åŒºåŸŸ -->
        <div class="log-panel">
            <div class="log-title">ğŸ“ è¿è¡Œæ—¥å¿—</div>
            <div class="log-area" id="logArea"></div>
        </div>
    </div>

    <script>
        // ==================== ç¬¬ä¸€æ­¥ï¼šåŸºç¡€æ¡†æ¶ ====================
        
        // å…¨å±€é…ç½®
        const CONFIG = {
            windowCount: 20,  // çª—å£æ•°é‡
            apiUrl: '',
            apiKey: '',
            model: '',
            batchSize: 20
        };
        
        // çª—å£çŠ¶æ€æ•°ç»„
        let windows = [];
        
        // å…¨å±€ç»Ÿè®¡
        let stats = {
            pending: 0,
            processing: 0,
            completed: 0,
            failed: 0
        };
        
        // å…¨å±€æ§åˆ¶çŠ¶æ€
        let isRunning = false;
        let isPaused = false;
        
        // åˆå§‹åŒ–çª—å£æ•°æ®ç»“æ„
        function initWindows() {
            windows = [];
            for (let i = 0; i < CONFIG.windowCount; i++) {
                windows.push({
                    id: i,
                    status: 'idle',      // idle | processing | completed | error
                    currentFile: null,   // å½“å‰å¤„ç†çš„æ–‡ä»¶å¯¹è±¡
                    queue: [],           // å¾…å¤„ç†æ–‡ä»¶é˜Ÿåˆ—
                    progress: {
                        current: 0,
                        total: 0,
                        percent: 0
                    },
                    preview: {
                        original: '',
                        translated: ''
                    },
                    error: null
                });
            }
        }
        
        // ç”Ÿæˆçª—å£å¡ç‰‡HTML
        function createWindowCard(windowData) {
            const statusText = {
                'idle': 'ç©ºé—²',
                'processing': 'å¤„ç†ä¸­',
                'completed': 'å·²å®Œæˆ',
                'error': 'é”™è¯¯'
            };
            
            return `
                <div class="window-card ${windowData.status}" id="window-${windowData.id}">
                    <div class="window-header">
                        <span class="window-title">çª—å£ ${windowData.id + 1}</span>
                        <span class="window-status">
                            <span class="status-dot"></span>
                            <span class="status-text">${statusText[windowData.status]}</span>
                        </span>
                    </div>
                    <div class="window-file">
                        <span class="icon">ğŸ“„</span>
                        <span class="filename">${windowData.currentFile ? windowData.currentFile.name : 'ç­‰å¾…åˆ†é…æ–‡ä»¶...'}</span>
                    </div>
                    <div class="window-progress">
                        <div class="progress-bar-bg">
                            <div class="progress-bar-fill" style="width: ${windowData.progress.percent}%">
                                ${windowData.progress.percent > 0 ? windowData.progress.percent + '%' : ''}
                            </div>
                        </div>
                        <div class="progress-text">${windowData.progress.current}/${windowData.progress.total} æ¡å­—å¹•</div>
                    </div>
                    <div class="window-preview">
                        <div class="preview-label">åŸæ–‡:</div>
                        <div class="preview-text original">${windowData.preview.original || '-'}</div>
                        <div class="preview-label">è¯‘æ–‡:</div>
                        <div class="preview-text translated">${windowData.preview.translated || '-'}</div>
                    </div>
                    <div class="window-queue">
                        é˜Ÿåˆ—: <span class="count">${windowData.queue.length}</span> ä¸ªæ–‡ä»¶å¾…å¤„ç†
                    </div>
                </div>
            `;
        }
        
        // æ¸²æŸ“æ‰€æœ‰çª—å£
        function renderWindows() {
            const grid = document.getElementById('windowsGrid');
            grid.innerHTML = windows.map(w => createWindowCard(w)).join('');
        }
        
        // æ›´æ–°å•ä¸ªçª—å£æ˜¾ç¤º
        function updateWindowUI(windowId) {
            const windowData = windows[windowId];
            const card = document.getElementById(`window-${windowId}`);
            if (!card) return;
            
            const statusText = {
                'idle': 'ç©ºé—²',
                'processing': 'å¤„ç†ä¸­',
                'completed': 'å·²å®Œæˆ',
                'error': 'é”™è¯¯'
            };
            
            // æ›´æ–°å¡ç‰‡çŠ¶æ€ç±»
            card.className = `window-card ${windowData.status}`;
            
            // æ›´æ–°çŠ¶æ€æ–‡æœ¬
            card.querySelector('.status-text').textContent = statusText[windowData.status];
            
            // æ›´æ–°æ–‡ä»¶å
            card.querySelector('.filename').textContent = 
                windowData.currentFile ? windowData.currentFile.name : 'ç­‰å¾…åˆ†é…æ–‡ä»¶...';
            
            // æ›´æ–°è¿›åº¦æ¡
            const progressFill = card.querySelector('.progress-bar-fill');
            progressFill.style.width = windowData.progress.percent + '%';
            progressFill.textContent = windowData.progress.percent > 0 ? windowData.progress.percent + '%' : '';
            
            // æ›´æ–°è¿›åº¦æ–‡æœ¬
            card.querySelector('.progress-text').textContent = 
                `${windowData.progress.current}/${windowData.progress.total} æ¡å­—å¹•`;
            
            // æ›´æ–°é¢„è§ˆ
            card.querySelector('.preview-text.original').textContent = windowData.preview.original || '-';
            card.querySelector('.preview-text.translated').textContent = windowData.preview.translated || '-';
            
            // æ›´æ–°é˜Ÿåˆ—æ•°é‡
            card.querySelector('.window-queue .count').textContent = windowData.queue.length;
        }
        
        // æ›´æ–°å…¨å±€ç»Ÿè®¡æ˜¾ç¤º
        function updateStats() {
            document.getElementById('statPending').textContent = stats.pending;
            document.getElementById('statProcessing').textContent = stats.processing;
            document.getElementById('statCompleted').textContent = stats.completed;
            document.getElementById('statFailed').textContent = stats.failed;
            
            // æ›´æ–°æŒ‰é’®çŠ¶æ€
            const hasFiles = stats.pending > 0 || stats.processing > 0;
            document.getElementById('btnStart').disabled = !hasFiles || isRunning;
            document.getElementById('btnPause').disabled = !isRunning;
        }
        
        // æ·»åŠ æ—¥å¿—
        function addLog(message, type = 'info') {
            const logArea = document.getElementById('logArea');
            const time = new Date().toLocaleTimeString();
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${time}] ${message}`;
            logArea.appendChild(entry);
            logArea.scrollTop = logArea.scrollHeight;
        }
        
        // è¯»å–é…ç½®
        function readConfig() {
            CONFIG.apiUrl = document.getElementById('apiUrl').value.trim();
            CONFIG.apiKey = document.getElementById('apiKey').value.trim();
            CONFIG.model = document.getElementById('model').value.trim();
            CONFIG.batchSize = parseInt(document.getElementById('batchSize').value);
        }
        
        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
        function initEventListeners() {
            // å¼€å§‹æŒ‰é’®
            document.getElementById('btnStart').addEventListener('click', startTranslation);
            
            // æš‚åœæŒ‰é’®
            document.getElementById('btnPause').addEventListener('click', togglePause);
            
            // æ¸…ç©ºæŒ‰é’®
            document.getElementById('btnClear').addEventListener('click', clearAllQueues);
            
            // æ‹–æ”¾åŒºåŸŸç‚¹å‡»
            document.getElementById('dropZone').addEventListener('click', selectFiles);
        }
        
        // ==================== ç¬¬ä¸‰æ­¥ï¼šç¿»è¯‘å¤„ç†åŠŸèƒ½ ====================
        
        // æ£€æµ‹æ–‡æœ¬ç¼–ç å¹¶è§£ç 
        async function readFileWithEncoding(file) {
            // é¦–å…ˆå°è¯•è¯»å–åŸå§‹å­—èŠ‚
            const buffer = await file.arrayBuffer();
            const bytes = new Uint8Array(buffer);
            
            // æ£€æµ‹BOMæ ‡è®°
            if (bytes[0] === 0xEF && bytes[1] === 0xBB && bytes[2] === 0xBF) {
                // UTF-8 with BOM
                return new TextDecoder('utf-8').decode(buffer);
            }
            if (bytes[0] === 0xFF && bytes[1] === 0xFE) {
                // UTF-16 LE
                return new TextDecoder('utf-16le').decode(buffer);
            }
            if (bytes[0] === 0xFE && bytes[1] === 0xFF) {
                // UTF-16 BE
                return new TextDecoder('utf-16be').decode(buffer);
            }
            
            // å°è¯•æ£€æµ‹æ˜¯å¦ä¸ºæœ‰æ•ˆçš„UTF-8
            if (isValidUTF8(bytes)) {
                const text = new TextDecoder('utf-8').decode(buffer);
                // æ£€æŸ¥æ˜¯å¦æœ‰ä¹±ç ç‰¹å¾ï¼ˆè¿ç»­çš„æ›¿æ¢å­—ç¬¦ï¼‰
                if (!text.includes('\uFFFD\uFFFD')) {
                    return text;
                }
            }
            
            // å°è¯•GBKç¼–ç ï¼ˆä¸­æ–‡Windowså¸¸ç”¨ï¼‰
            try {
                const gbkDecoder = new TextDecoder('gbk');
                const gbkText = gbkDecoder.decode(buffer);
                // æ£€æŸ¥è§£ç ç»“æœæ˜¯å¦åŒ…å«æœ‰æ•ˆä¸­æ–‡å­—ç¬¦
                if (containsChinese(gbkText) && !gbkText.includes('\uFFFD')) {
                    return gbkText;
                }
            } catch (e) {
                // GBKè§£ç å™¨ä¸å¯ç”¨
            }
            
            // å°è¯•GB2312ç¼–ç 
            try {
                const gb2312Decoder = new TextDecoder('gb2312');
                const gb2312Text = gb2312Decoder.decode(buffer);
                if (containsChinese(gb2312Text) && !gb2312Text.includes('\uFFFD')) {
                    return gb2312Text;
                }
            } catch (e) {
                // GB2312è§£ç å™¨ä¸å¯ç”¨
            }
            
            // å°è¯•Big5ç¼–ç ï¼ˆç¹ä½“ä¸­æ–‡ï¼‰
            try {
                const big5Decoder = new TextDecoder('big5');
                const big5Text = big5Decoder.decode(buffer);
                if (containsChinese(big5Text) && !big5Text.includes('\uFFFD')) {
                    return big5Text;
                }
            } catch (e) {
                // Big5è§£ç å™¨ä¸å¯ç”¨
            }
            
            // å°è¯•Shift_JISç¼–ç ï¼ˆæ—¥è¯­ï¼‰
            try {
                const sjisDecoder = new TextDecoder('shift_jis');
                const sjisText = sjisDecoder.decode(buffer);
                if (containsJapanese(sjisText) && !sjisText.includes('\uFFFD')) {
                    return sjisText;
                }
            } catch (e) {
                // Shift_JISè§£ç å™¨ä¸å¯ç”¨
            }
            
            // å°è¯•EUC-KRç¼–ç ï¼ˆéŸ©è¯­ï¼‰
            try {
                const euckrDecoder = new TextDecoder('euc-kr');
                const euckrText = euckrDecoder.decode(buffer);
                if (containsKorean(euckrText) && !euckrText.includes('\uFFFD')) {
                    return euckrText;
                }
            } catch (e) {
                // EUC-KRè§£ç å™¨ä¸å¯ç”¨
            }
            
            // é»˜è®¤ä½¿ç”¨UTF-8
            return new TextDecoder('utf-8').decode(buffer);
        }
        
        // æ£€æŸ¥æ˜¯å¦ä¸ºæœ‰æ•ˆçš„UTF-8ç¼–ç 
        function isValidUTF8(bytes) {
            let i = 0;
            while (i < bytes.length) {
                if (bytes[i] < 0x80) {
                    i++;
                } else if ((bytes[i] & 0xE0) === 0xC0) {
                    if (i + 1 >= bytes.length || (bytes[i + 1] & 0xC0) !== 0x80) return false;
                    i += 2;
                } else if ((bytes[i] & 0xF0) === 0xE0) {
                    if (i + 2 >= bytes.length || (bytes[i + 1] & 0xC0) !== 0x80 || (bytes[i + 2] & 0xC0) !== 0x80) return false;
                    i += 3;
                } else if ((bytes[i] & 0xF8) === 0xF0) {
                    if (i + 3 >= bytes.length || (bytes[i + 1] & 0xC0) !== 0x80 || (bytes[i + 2] & 0xC0) !== 0x80 || (bytes[i + 3] & 0xC0) !== 0x80) return false;
                    i += 4;
                } else {
                    return false;
                }
            }
            return true;
        }
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«ä¸­æ–‡å­—ç¬¦
        function containsChinese(text) {
            return /[\u4e00-\u9fff]/.test(text);
        }
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«æ—¥è¯­å­—ç¬¦ï¼ˆå¹³å‡åã€ç‰‡å‡åï¼‰
        function containsJapanese(text) {
            return /[\u3040-\u309f\u30a0-\u30ff]/.test(text);
        }
        
        // æ£€æŸ¥æ˜¯å¦åŒ…å«éŸ©è¯­å­—ç¬¦
        function containsKorean(text) {
            return /[\uac00-\ud7af\u1100-\u11ff]/.test(text);
        }
        
        // è§£æSRTæ–‡ä»¶å†…å®¹
        function parseSRT(content) {
            const result = [];
            const blocks = content.trim().split(/\n\s*\n/);
            
            for (const block of blocks) {
                const lines = block.trim().split('\n');
                if (lines.length >= 3) {
                    const index = parseInt(lines[0]);
                    const timeMatch = lines[1].match(/(\d{2}:\d{2}:\d{2},\d{3})\s*-->\s*(\d{2}:\d{2}:\d{2},\d{3})/);
                    if (timeMatch && !isNaN(index)) {
                        result.push({
                            index: index,
                            start: timeMatch[1],
                            end: timeMatch[2],
                            text: lines.slice(2).join('\n')
                        });
                    }
                }
            }
            return result;
        }
        
        // ç”ŸæˆSRTæ ¼å¼è¾“å‡º
        function generateSRT(subtitles) {
            return subtitles.map(s => 
                `${s.index}\n${s.start} --> ${s.end}\n${s.text}`
            ).join('\n\n');
        }
        
        // è°ƒç”¨ç¿»è¯‘API
        async function translateBatch(texts, windowId) {
            readConfig();
            
            const numberedTexts = texts.map((t, i) => `[${i + 1}] ${t}`).join('\n');
            
            const response = await fetch(CONFIG.apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${CONFIG.apiKey}`
                },
                body: JSON.stringify({
                    model: CONFIG.model,
                    messages: [{
                        role: 'user',
                        content: `ä½ æ˜¯ä¸“ä¸šå­—å¹•ç¿»è¯‘å‘˜ã€‚å°†ä»¥ä¸‹å­—å¹•ç¿»è¯‘æˆç®€ä½“ä¸­æ–‡ã€‚

è§„åˆ™ï¼š
1. ä¿æŒ[æ•°å­—]æ ¼å¼ä¸å˜
2. æ¯è¡Œç¿»è¯‘å¯¹åº”åŸæ–‡çš„[æ•°å­—]
3. åªè¾“å‡ºç¿»è¯‘ç»“æœï¼Œä¸è¦è§£é‡Š

åŸæ–‡ï¼š
${numberedTexts}`
                    }],
                    temperature: 0.3,
                    max_tokens: 4000
                })
            });
            
            if (!response.ok) {
                throw new Error(`APIé”™è¯¯ ${response.status}`);
            }
            
            const data = await response.json();
            const content = data.choices[0].message.content;
            
            // è§£æç¿»è¯‘ç»“æœ
            const translations = [];
            const lines = content.split('\n');
            
            for (const line of lines) {
                const match = line.match(/\[(\d+)\]\s*(.+)/);
                if (match) {
                    const idx = parseInt(match[1]) - 1;
                    if (idx >= 0 && idx < texts.length) {
                        translations[idx] = match[2].trim();
                    }
                }
            }
            
            // å¡«å……æœªç¿»è¯‘çš„æ¡ç›®
            for (let i = 0; i < texts.length; i++) {
                if (!translations[i]) {
                    translations[i] = texts[i];  // ä¿ç•™åŸæ–‡
                }
            }
            
            return translations;
        }
        
        // å¤„ç†å•ä¸ªçª—å£çš„ç¿»è¯‘ä»»åŠ¡
        async function processWindow(windowId) {
            const windowData = windows[windowId];
            
            while (windowData.queue.length > 0 && isRunning && !isPaused) {
                // è·å–ä¸‹ä¸€ä¸ªæ–‡ä»¶
                const fileObj = windowData.queue.shift();
                windowData.currentFile = fileObj;
                windowData.status = 'processing';
                windowData.progress = { current: 0, total: 0, percent: 0 };
                windowData.error = null;
                
                updateWindowUI(windowId);
                recalculateStats();
                updateStats();
                
                addLog(`çª—å£${windowId + 1}: å¼€å§‹ç¿»è¯‘ ${fileObj.name}`, 'info');
                
                try {
                    // è¯»å–æ–‡ä»¶å†…å®¹ï¼ˆè‡ªåŠ¨æ£€æµ‹ç¼–ç ï¼‰
                    const content = await readFileWithEncoding(fileObj.file);
                    
                    // è§£æSRT
                    const subtitles = parseSRT(content);
                    if (subtitles.length === 0) {
                        throw new Error('æ— æ³•è§£æSRTæ–‡ä»¶');
                    }
                    
                    windowData.progress.total = subtitles.length;
                    updateWindowUI(windowId);
                    
                    // åˆ†æ‰¹ç¿»è¯‘
                    const translatedSubs = [];
                    const batchSize = CONFIG.batchSize;
                    
                    for (let i = 0; i < subtitles.length; i += batchSize) {
                        if (!isRunning || isPaused) break;
                        
                        const batch = subtitles.slice(i, i + batchSize);
                        const texts = batch.map(s => s.text);
                        
                        // æ›´æ–°é¢„è§ˆ
                        windowData.preview.original = texts[0].substring(0, 50);
                        updateWindowUI(windowId);
                        
                        // è°ƒç”¨ç¿»è¯‘APIï¼ˆå¸¦é‡è¯•ï¼‰
                        let translations;
                        let retries = 3;
                        
                        while (retries > 0) {
                            try {
                                translations = await translateBatch(texts, windowId);
                                break;
                            } catch (err) {
                                retries--;
                                if (retries === 0) throw err;
                                addLog(`çª—å£${windowId + 1}: APIè°ƒç”¨å¤±è´¥ï¼Œé‡è¯•ä¸­...`, 'warning');
                                await new Promise(r => setTimeout(r, 2000));
                            }
                        }
                        
                        // åˆå¹¶ç¿»è¯‘ç»“æœ
                        for (let j = 0; j < batch.length; j++) {
                            translatedSubs.push({
                                ...batch[j],
                                text: translations[j]
                            });
                        }
                        
                        // æ›´æ–°è¿›åº¦
                        windowData.progress.current = translatedSubs.length;
                        windowData.progress.percent = Math.round((translatedSubs.length / subtitles.length) * 100);
                        windowData.preview.translated = translations[0].substring(0, 50);
                        updateWindowUI(windowId);
                        
                        // çŸ­æš‚å»¶è¿Ÿé¿å…APIé™æµ
                        if (i + batchSize < subtitles.length) {
                            await new Promise(r => setTimeout(r, 500));
                        }
                    }
                    
                    // ç”Ÿæˆç¿»è¯‘åçš„SRTå†…å®¹
                    const translatedContent = generateSRT(translatedSubs);
                    
                    // ä¿å­˜æ–‡ä»¶
                    const newFileName = fileObj.name.replace(/\.srt$/i, '_ä¸­æ–‡.srt');
                    await saveFile(fileObj, newFileName, translatedContent);
                    
                    // æ ‡è®°å®Œæˆ
                    windowData.status = 'completed';
                    stats.completed++;
                    addLog(`çª—å£${windowId + 1}: âœ“ å®Œæˆ ${fileObj.name}`, 'success');
                    
                } catch (err) {
                    windowData.status = 'error';
                    windowData.error = err.message;
                    stats.failed++;
                    addLog(`çª—å£${windowId + 1}: âœ— å¤±è´¥ ${fileObj.name} - ${err.message}`, 'error');
                }
                
                updateWindowUI(windowId);
                recalculateStats();
                updateStats();
            }
            
            // é˜Ÿåˆ—å¤„ç†å®Œæ¯•ï¼Œçª—å£å˜ä¸ºç©ºé—²
            if (windowData.queue.length === 0) {
                windowData.status = 'idle';
                windowData.currentFile = null;
                updateWindowUI(windowId);
            }
        }
        
        // ä¿å­˜ç¿»è¯‘åçš„æ–‡ä»¶
        async function saveFile(fileObj, newFileName, content) {
            // å°è¯•ä½¿ç”¨File System Access APIä¿å­˜åˆ°åŸä½ç½®
            if (fileObj.dirHandle) {
                try {
                    const newHandle = await fileObj.dirHandle.getFileHandle(newFileName, { create: true });
                    const writable = await newHandle.createWritable();
                    await writable.write(content);
                    await writable.close();
                    return;
                } catch (err) {
                    addLog(`ä¿å­˜åˆ°åŸä½ç½®å¤±è´¥ï¼Œå°†ä¸‹è½½æ–‡ä»¶`, 'warning');
                }
            }
            
            // é™çº§ï¼šè§¦å‘ä¸‹è½½
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = newFileName;
            a.click();
            URL.revokeObjectURL(url);
        }
        
        // å¼€å§‹ç¿»è¯‘ï¼ˆå¯åŠ¨æ‰€æœ‰çª—å£å¹¶è¡Œå¤„ç†ï¼‰
        async function startTranslation() {
            if (isRunning) return;
            
            readConfig();
            
            // éªŒè¯é…ç½®
            if (!CONFIG.apiUrl || !CONFIG.apiKey || !CONFIG.model) {
                addLog('è¯·å…ˆé…ç½®APIåœ°å€ã€å¯†é’¥å’Œæ¨¡å‹', 'error');
                return;
            }
            
            // æ£€æŸ¥æ˜¯å¦æœ‰å¾…å¤„ç†æ–‡ä»¶
            const totalPending = windows.reduce((sum, w) => sum + w.queue.length, 0);
            if (totalPending === 0) {
                addLog('æ²¡æœ‰å¾…å¤„ç†çš„æ–‡ä»¶', 'warning');
                return;
            }
            
            isRunning = true;
            isPaused = false;
            
            document.getElementById('btnStart').disabled = true;
            document.getElementById('btnPause').disabled = false;
            
            addLog(`å¼€å§‹å¹¶è¡Œç¿»è¯‘ï¼Œå…± ${totalPending} ä¸ªæ–‡ä»¶`, 'info');
            
            // å¯åŠ¨æ‰€æœ‰çª—å£çš„å¤„ç†ä»»åŠ¡ï¼ˆçœŸæ­£çš„å¹¶è¡Œï¼‰
            const promises = windows.map((w, i) => processWindow(i));
            
            // ç­‰å¾…æ‰€æœ‰çª—å£å®Œæˆ
            await Promise.all(promises);
            
            isRunning = false;
            document.getElementById('btnStart').disabled = false;
            document.getElementById('btnPause').disabled = true;
            document.getElementById('btnPause').textContent = 'â¸ï¸ æš‚åœ';
            
            addLog(`ç¿»è¯‘ä»»åŠ¡å®Œæˆï¼æˆåŠŸ: ${stats.completed}, å¤±è´¥: ${stats.failed}`, 'success');
        }
        
        // æš‚åœ/ç»§ç»­ï¼ˆå ä½å‡½æ•°ï¼Œç¬¬ä¸‰æ­¥å®ç°ï¼‰
        function togglePause() {
            isPaused = !isPaused;
            const btn = document.getElementById('btnPause');
            btn.textContent = isPaused ? 'â–¶ï¸ ç»§ç»­' : 'â¸ï¸ æš‚åœ';
            addLog(isPaused ? 'ç¿»è¯‘å·²æš‚åœ' : 'ç¿»è¯‘å·²ç»§ç»­', 'warning');
        }
        
        // æ¸…ç©ºæ‰€æœ‰é˜Ÿåˆ—
        function clearAllQueues() {
            windows.forEach(w => {
                w.queue = [];
                w.currentFile = null;
                w.status = 'idle';
                w.progress = { current: 0, total: 0, percent: 0 };
                w.preview = { original: '', translated: '' };
            });
            stats = { pending: 0, processing: 0, completed: 0, failed: 0 };
            renderWindows();
            updateStats();
            addLog('å·²æ¸…ç©ºæ‰€æœ‰é˜Ÿåˆ—', 'warning');
        }
        
        // ==================== ç¬¬äºŒæ­¥ï¼šæ–‡ä»¶æ‹–æ”¾ä¸åˆ†å‘ç³»ç»Ÿ ====================
        
        // é€‰æ‹©æ–‡ä»¶
        async function selectFiles() {
            try {
                // ä½¿ç”¨File System Access APIé€‰æ‹©å¤šä¸ªæ–‡ä»¶
                const fileHandles = await window.showOpenFilePicker({
                    multiple: true,
                    types: [{
                        description: 'SRTå­—å¹•æ–‡ä»¶',
                        accept: { 'text/plain': ['.srt'] }
                    }]
                });
                
                const files = [];
                for (const handle of fileHandles) {
                    const file = await handle.getFile();
                    files.push({
                        file: file,
                        handle: handle,
                        name: file.name,
                        dirHandle: null  // å•æ–‡ä»¶é€‰æ‹©æ²¡æœ‰ç›®å½•å¥æŸ„
                    });
                }
                
                if (files.length > 0) {
                    distributeFiles(files);
                }
            } catch (err) {
                if (err.name !== 'AbortError') {
                    addLog(`é€‰æ‹©æ–‡ä»¶å¤±è´¥: ${err.message}`, 'error');
                }
            }
        }
        
        // åˆå§‹åŒ–æ‹–æ”¾äº‹ä»¶
        function initDragDrop() {
            const dropZone = document.getElementById('dropZone');
            
            // é˜»æ­¢é»˜è®¤æ‹–æ”¾è¡Œä¸º
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                dropZone.addEventListener(eventName, (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                });
            });
            
            // æ‹–å…¥æ•ˆæœ
            dropZone.addEventListener('dragenter', () => {
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragover', () => {
                dropZone.classList.add('dragover');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                // åªæœ‰çœŸæ­£ç¦»å¼€dropZoneæ—¶æ‰ç§»é™¤æ•ˆæœ
                if (!dropZone.contains(e.relatedTarget)) {
                    dropZone.classList.remove('dragover');
                }
            });
            
            // å¤„ç†æ–‡ä»¶æ”¾ä¸‹
            dropZone.addEventListener('drop', async (e) => {
                dropZone.classList.remove('dragover');
                
                const items = e.dataTransfer.items;
                const files = [];
                
                addLog(`æ£€æµ‹åˆ°æ‹–å…¥ ${items.length} ä¸ªé¡¹ç›®...`, 'info');
                
                // æ”¶é›†æ‰€æœ‰æ–‡ä»¶
                const processPromises = [];
                
                for (let i = 0; i < items.length; i++) {
                    const item = items[i];
                    if (item.kind === 'file') {
                        // å°è¯•è·å–æ–‡ä»¶ç³»ç»Ÿå¥æŸ„ï¼ˆæ”¯æŒæ–‡ä»¶å¤¹ï¼‰
                        if (item.getAsFileSystemHandle) {
                            processPromises.push(
                                item.getAsFileSystemHandle().then(handle => 
                                    processHandle(handle, files)
                                ).catch(err => {
                                    // é™çº§å¤„ç†
                                    const file = item.getAsFile();
                                    if (file && file.name.toLowerCase().endsWith('.srt')) {
                                        files.push({
                                            file: file,
                                            handle: null,
                                            name: file.name,
                                            dirHandle: null
                                        });
                                    }
                                })
                            );
                        } else {
                            // ä¸æ”¯æŒgetAsFileSystemHandleï¼Œç›´æ¥è·å–æ–‡ä»¶
                            const file = item.getAsFile();
                            if (file && file.name.toLowerCase().endsWith('.srt')) {
                                files.push({
                                    file: file,
                                    handle: null,
                                    name: file.name,
                                    dirHandle: null
                                });
                            }
                        }
                    }
                }
                
                // ç­‰å¾…æ‰€æœ‰å¤„ç†å®Œæˆ
                await Promise.all(processPromises);
                
                if (files.length > 0) {
                    addLog(`å…±æ‰¾åˆ° ${files.length} ä¸ªSRTæ–‡ä»¶`, 'success');
                    distributeFiles(files);
                } else {
                    addLog('æœªæ‰¾åˆ°SRTæ–‡ä»¶', 'warning');
                }
            });
        }
        
        // å¤„ç†æ–‡ä»¶ç³»ç»Ÿå¥æŸ„ï¼ˆæ”¯æŒæ–‡ä»¶å¤¹é€’å½’ï¼‰
        async function processHandle(handle, files, dirHandle = null) {
            if (handle.kind === 'file') {
                if (handle.name.toLowerCase().endsWith('.srt')) {
                    const file = await handle.getFile();
                    files.push({
                        file: file,
                        handle: handle,
                        name: file.name,
                        dirHandle: dirHandle
                    });
                }
            } else if (handle.kind === 'directory') {
                // é€’å½’å¤„ç†æ–‡ä»¶å¤¹
                addLog(`æ‰«ææ–‡ä»¶å¤¹: ${handle.name}`, 'info');
                for await (const entry of handle.values()) {
                    await processHandle(entry, files, handle);
                }
            }
        }
        
        // æ™ºèƒ½åˆ†å‘æ–‡ä»¶åˆ°å„çª—å£
        function distributeFiles(files) {
            addLog(`å¼€å§‹åˆ†å‘ ${files.length} ä¸ªæ–‡ä»¶åˆ°å„çª—å£...`, 'info');
            
            // ä½¿ç”¨è´Ÿè½½å‡è¡¡ç®—æ³•ï¼šä¼˜å…ˆåˆ†é…ç»™é˜Ÿåˆ—æœ€çŸ­çš„çª—å£
            files.forEach((fileObj, index) => {
                // æ‰¾åˆ°é˜Ÿåˆ—æœ€çŸ­çš„çª—å£
                let minQueueWindow = windows[0];
                let minQueueLength = windows[0].queue.length;
                
                for (let i = 1; i < windows.length; i++) {
                    if (windows[i].queue.length < minQueueLength) {
                        minQueueLength = windows[i].queue.length;
                        minQueueWindow = windows[i];
                    }
                }
                
                // å°†æ–‡ä»¶æ·»åŠ åˆ°è¯¥çª—å£çš„é˜Ÿåˆ—
                minQueueWindow.queue.push(fileObj);
                
                // æ›´æ–°çª—å£æ˜¾ç¤º
                updateWindowUI(minQueueWindow.id);
            });
            
            // æ›´æ–°ç»Ÿè®¡
            recalculateStats();
            updateStats();
            
            addLog(`æ–‡ä»¶åˆ†å‘å®Œæˆï¼Œå·²åˆ†é…åˆ° ${CONFIG.windowCount} ä¸ªçª—å£`, 'success');
            
            // æ˜¾ç¤ºå„çª—å£é˜Ÿåˆ—æƒ…å†µ
            const queueInfo = windows.map((w, i) => `W${i+1}:${w.queue.length}`).join(' ');
            addLog(`å„çª—å£é˜Ÿåˆ—: ${queueInfo}`, 'info');
        }
        
        // é‡æ–°è®¡ç®—ç»Ÿè®¡æ•°æ®
        function recalculateStats() {
            stats.pending = 0;
            stats.processing = 0;
            stats.completed = 0;
            stats.failed = 0;
            
            windows.forEach(w => {
                // é˜Ÿåˆ—ä¸­çš„æ–‡ä»¶ç®—ä½œå¾…å¤„ç†
                stats.pending += w.queue.length;
                
                // å½“å‰æ­£åœ¨å¤„ç†çš„æ–‡ä»¶
                if (w.status === 'processing' && w.currentFile) {
                    stats.processing++;
                }
            });
        }
        
        // é¡µé¢åŠ è½½å®Œæˆååˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            initWindows();
            renderWindows();
            updateStats();
            initEventListeners();
            initDragDrop();  // åˆå§‹åŒ–æ‹–æ”¾åŠŸèƒ½
            addLog('ç³»ç»Ÿåˆå§‹åŒ–å®Œæˆï¼Œ20ä¸ªç¿»è¯‘çª—å£å·²å°±ç»ª', 'success');
            addLog('è¯·æ‹–æ‹½SRTæ–‡ä»¶åˆ°ä¸Šæ–¹åŒºåŸŸå¼€å§‹å¤„ç†', 'info');
        });
    </script>
</body>
</html>
